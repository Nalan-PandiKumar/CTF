Entry point address: 0x8048540 (__start)
__libc_start_main -> 0x080484d0@plt
main -> 0x814c22c
fcn.0811d5b3 -> some function called by main
fcn.080486b1 -> some function called by fcn.0811d5b3


### Intel syntax, disassemble only that address range
	`objdump -dM intel --start-address=0x080486b1 --stop-address=0x08048839 ./vuln`

@fcn.080486b1:
ebx(fcn.080486b1) -> 0x080486bd + 0x10d943 => 0x8156000

arg1:- 0x8156000 - 0x98a5 = 0x814c75b
printf("%zu?",prompt);

char input[9] -> one byte overflow
arg1:- 0x8156000 - 0x989f = 0x814c761
scanf("%9s",input);

;strnlen(const char *s, size_t maxlen)
size_t input_length = strnlen(str,8);



if(input[input_length] == '\n')
	input[input_length] = '\0';


edx = 0x88888889 // This is a compiler computed magic number for integer division without floating point instructions
eax = prompt

mul edx


For Example:-
	result = x / divisor
	result = x * (1 / divisor)
	
	To store the fractional part in integer encoding it uses fixed point computation.
	magic_number = round((1 / divisor) * 2 ** N)	// N -> scaling factor no.of fraction bits you want to store in integer.

	1. quotient = ( x * magic_number ) >> N

	2. remainder = x - quotient * divisor

	From the above formula divisor can be calculated from:-

	1. divisor = round(2 ** N / magic_number)
