// board is a variable in .bss section (data segment)
// flag is a variable in .bss section (data segment)
// _do_you_like_gittens is a variable in .bss section (data segment)
// _does_gittens_watch_cat_videos is a variable in .bss section (data segment)

int main()
{
    int result;
    FILE* fp;
    size_t length;
    int i;
    FILE *stream;
    
    setvbuf(_stdout, 0, 2, 0);
    fp = fopen("flag.txt", 'r');
    fscanf(fp, "%s", flag); 
    fclose(fp);

    puts("Enter homework sol");

    //char board[50][23] ;1150 bytes

    ROWS = 50; // 0x32
    COLS = 22; // 0x16

    //board[i * 22] = board[i] (ROW MAJOR MAPPING)


    for (i = 0; i < 4; i++) {
        board = fgets(board + i * 22, COLS + 1, STDIN); // board = board + i * 22

        if ((board == 0) || (board[i * 22] == 'R')) 
            break;

        length = strlen(board + i * 22);
        *(char *)(board + i * 22 + length - 1) = 0;
        //board[i][length - 1] = '\0';
    }

    do {
        result = step();
    } while (result != 0);


    _do_you_like_gittens = 1;
    _does_gittens_watch_cat_videos = 1;
    return 0;
}



int step(void) {
    // instruction pointer (i, j)
    char instr = board[i * 0x16 + j];   // looks like 0x16 == 22 = number of columns
                                        // so board is a 2D grid flattened row-major

    switch (instr) {

    case '!': // logical NOT on top of stack
        assert(_sn >= 1);
        stack[_sn - 1] = (stack[_sn - 1] == 0) ? 1 : 0;
        break;

    case '0': // push 0
        assert(_sn < 100);
        stack[_sn++] = 0;
        break;

    case '$': // pop
        assert(_sn >= 1);
        _sn--;
        break;

    case '%': // modulo
        assert(_sn >= 2);
        stack[_sn - 2] = stack[_sn - 2] % stack[_sn - 1];
        _sn--;
        break;

    case '*': // multiply
        assert(_sn >= 2);
        stack[_sn - 2] = stack[_sn - 2] * stack[_sn - 1];
        _sn--;
        break;

    case '+': // add
        assert(_sn >= 2);
        stack[_sn - 2] = stack[_sn - 2] + stack[_sn - 1];
        _sn--;
        break;

    case ',': // output character
        assert(_sn >= 1);
        putchar(stack[--_sn]);
        break;

    case '-': // subtract
        assert(_sn >= 2);
        stack[_sn - 2] = stack[_sn - 2] - stack[_sn - 1];
        _sn--;
        break;

    case '.': //print top value
        assert(_sn >= 1);
        printf("%d", stack[--_sn]);
        break;

    case '/': // divide
        assert(_sn >= 2);
        stack[_sn - 2] = stack[_sn - 2] / stack[_sn - 1];
        _sn--;
        break;

    case ':': // duplicate top
        assert(_sn >= 1);
        stack[_sn] = stack[_sn - 1];
        _sn++;
        break;

    case '<': // move left
        _dirx = -1; _diry = 0;
        break;

    case '>': // move right
        _dirx = 1; _diry = 0;
        break;

    case '@': // terminate
        return 0;

    case '\\': // swap top two elements (XOR swap in disasm)
        assert(_sn >= 2);
        {
            int tmp = stack[_sn - 1];
            stack[_sn - 1] = stack[_sn - 2];
            stack[_sn - 2] = tmp;
        }
        break;

    case '^': // move up
        _dirx = 0; _diry = -1;
        break;

    case '_': // horizontal if: pop, move right if 0 else left
        assert(_sn >= 1);
        if (stack[--_sn] == 0) {
            _dirx = 1; _diry = 0;
        } else {
            _dirx = -1; _diry = 0;
        }
        break;

    case '`': // greater-than: a b -> (a < b)
        assert(_sn >= 2);
        stack[_sn - 2] = (stack[_sn - 1] < stack[_sn - 2]) ? 1 : 0;
        _sn--;
        break;

    case 'g': // get (board[y][x])
        assert(_sn >= 2);
        {
            int x = stack[_sn - 2];
            int y = stack[_sn - 1];
            assert(x >= 0 && y >= 0);
            assert(x < _cols && y < _rows);
            stack[_sn - 2] = board[y * 0x16 + x];
            _sn--;
        }
        break;

    case 'p': // put (board[y][x] = value)
        assert(_sn >= 3);
        {
            int val = stack[_sn - 3];
            int x   = stack[_sn - 2];
            int y   = stack[_sn - 1];
            assert(x >= 0 && y >= 0);
            assert(x < _cols && y < _rows);
            board[y * 0x16 + x] = (char)val;
            _sn -= 3;
        }
        break;

    case 'v': // move down
        _dirx = 0; _diry = 1;
        break;

    case '|': // vertical if: pop, move down if 0 else up
        assert(_sn >= 1);
        if (stack[--_sn] == 0) {
            _dirx = 0; _diry = 1;
        } else {
            _dirx = 0; _diry = -1;
        }
        break;

    default:
        // unknown instruction = no-op
        break;
    }

    // update instruction pointer (wraparound)
    i = (i + _diry + _rows) % _rows;
    j = (j + _dirx + _cols) % _cols;
    return 1;
}
